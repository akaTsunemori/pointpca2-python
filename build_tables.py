import pandas as pd
import numpy as np
import matlab.engine
from argparse import ArgumentParser
from pointpca2 import lc_pointpca
from os.path import exists, join
from os import mkdir, listdir


def get_latest_csv(filenames, suffix):
    parse_error = \
    '''
    Error parsing the checkpoints on the tables/<dataset_path> folder.
    Make sure that the folder is empty or
    contains only csv files generated by this script.
    '''
    latest = None
    max_number = -1
    for filename in filenames:
        parts = filename.split('_')
        if len(parts) != 4:
            raise Exception(parse_error)
        number, _, _, status_with_extension = parts
        status = status_with_extension.split('.')[0]
        try:
            number = int(number)
        except ValueError:
            raise Exception(parse_error)
        if status == suffix and number > max_number:
            max_number = number
            latest = filename
    return latest


def build_tables(dataset_name, dataset_csv, pointpca2_path):
    eng = matlab.engine.start_matlab()
    pointpca2_path = join(pointpca2_path, 'Matlab_FeatureExtraction', 'lib')
    eng.addpath(pointpca2_path, nargout=0)
    print('MATLAB engine for Python successfully started!')
    if not exists('./tables'):
        mkdir('tables')
    if not exists(f'./tables/{dataset_name}'):
        mkdir(f'./tables/{dataset_name}')
    df_dataset = pd.read_csv(dataset_csv)
    df_dataset['SIGNAL'] = df_dataset['SIGNAL'].str.strip()
    df_dataset['REF'] = df_dataset['REF'].str.strip()
    df_dataset['LOCATION'] = df_dataset['LOCATION'].str.strip()
    df_dataset['REFLOCATION'] = df_dataset['REFLOCATION'].str.strip()
    FEATURES = [f'FEATURE_{i+1}' for i in range(40)]
    tables = listdir(f'./tables/{dataset_name}')
    Python_filename = get_latest_csv(tables, 'Python')
    MATLAB_filename = get_latest_csv(tables, 'MATLAB')
    common_columns = ['SIGNAL', 'REF', 'SCORE']
    if not Python_filename:
        df_result_Python = pd.DataFrame(columns=common_columns + FEATURES)
        df_result_Python[common_columns] = df_dataset[common_columns]
    else:
        df_result_Python = pd.read_csv(f'./tables/{dataset_name}/{Python_filename}', index_col=0)
    if not MATLAB_filename:
        df_result_MATLAB = pd.DataFrame(columns=['SIGNAL', 'REF', 'SCORE', *FEATURES])
        df_result_MATLAB[common_columns] = df_dataset[common_columns]
    else:
        df_result_MATLAB = pd.read_csv(f'./tables/{dataset_name}/{MATLAB_filename}', index_col=0)
    for index, row in df_dataset.iterrows():
        output_MATLAB = f'./tables/{dataset_name}/{index:06}_{dataset_name}_pointpca2_MATLAB.csv'
        output_Python = f'./tables/{dataset_name}/{index:06}_{dataset_name}_pointpca2_Python.csv'
        exists_MATLAB = exists(output_MATLAB)
        exists_Python = exists(output_Python)
        signal, ref = row['SIGNAL'], row['REF']
        signal_location, ref_location = row['LOCATION'], row['REFLOCATION']
        print(f'{index}/{len(df_dataset)}')
        print('REF/SIGNAL:', ref, signal)
        try:
            print('\tComputing lc_pointpca MATLAB')
            if not exists_MATLAB:
                lcpointpca_MATLAB = eng.lc_pointpca(
                    f'{signal_location}/{signal}',
                    f'{ref_location}/{ref}',
                    nargout=1)
                lcpointpca_MATLAB = np.array(lcpointpca_MATLAB)
                print(f'\t\tDone!')
            else:
                print(f'\t\tFound checkpoint at "{output_MATLAB}", skipping...')
            print('\tComputing lc_pointpca Python')
            if not exists_Python:
                lcpointpca_Python = lc_pointpca(
                    f'{signal_location}/{signal}',
                    f'{ref_location}/{ref}')
                print(f'\t\tDone!')
            else:
                print(f'\t\tFound checkpoint at "{output_Python}", skipping...')
        except Exception as e:
            print(e)
            continue
        for i in range(len(FEATURES)):
            if not exists_MATLAB:
                df_result_MATLAB.at[index, FEATURES[i]] = lcpointpca_MATLAB[i]
            if not exists_Python:
                df_result_Python.at[index, FEATURES[i]] = lcpointpca_Python[i]
        if not exists_MATLAB or not exists_Python:
            print('\tSaving checkpoints to disk')
        if not exists_MATLAB:
            df_result_MATLAB.to_csv(output_MATLAB)
        if not exists_Python:
            df_result_Python.to_csv(output_Python)
    eng.quit()


def get_args():
    parser = ArgumentParser()
    parser.add_argument('--dataset_name', type=str,
                        default='APSIPA')
    parser.add_argument('--dataset_csv', type=str,
                        default='/home/arthurc/Documents/APSIPA/apsipa.csv')
    parser.add_argument('--pointpca2_path', type=str,
                        default='/home/arthurc/Documents/pointpca2/')
    return parser.parse_args()


def main(args):
    '''
    Builds the tables with pointpca2 features for both the Python and MATLAB algorithms.
    This script expects that the dataset's csv's columns follow the format:
    SIGNAL,REF,SCORE,LOCATION,REFLOCATION,ATTACK,CLASS
    It also expects that the informed locations are correct.

    Any exceptions happened during the computations of the lc_pointpca will be ignored
    and the row will be skipped.

    Checkpoints will be saved on ./tables/dataset_name, DO NOT remove, rename or change
    any of these files unless you've finished building the tables for the whole dataset.
    Doing so would compromise the (very simple) checkpoint system.

    It is expected that the setup for 
    MATLAB (https://www.mathworks.com/products/matlab.html)
    and matlab.engine (https://pypi.org/project/matlabengine/)
    was properly done and tested.

    Tables for multiple datasets can be built at the same time, as long as you
    call this script multiple times with different values for dataset_name.
    '''
    dataset_name = args.dataset_name
    dataset_csv = args.dataset_csv
    pointpca2_path = args.pointpca2_path
    build_tables(dataset_name, dataset_csv, pointpca2_path)


if __name__ == '__main__':
    main(get_args())
